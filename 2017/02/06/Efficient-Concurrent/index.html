<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Life, Android, Code"><title>高效并发一 Java内存模型与Java线程 | 技术边界</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">高效并发一 Java内存模型与Java线程</h1><a id="logo" href="/.">技术边界</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">高效并发一 Java内存模型与Java线程</h1><div class="post-meta">Feb 6, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">Inhalte</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-硬件的效率与一致性"><span class="toc-number">1.</span> <span class="toc-text">1.1 硬件的效率与一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存一致性"><span class="toc-number">1.1.</span> <span class="toc-text">缓存一致性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Java-内存模型"><span class="toc-number">2.</span> <span class="toc-text">1.2 Java 内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-主内存与工作内存"><span class="toc-number">3.</span> <span class="toc-text">1.2.1 主内存与工作内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-内存间交互操作"><span class="toc-number">4.</span> <span class="toc-text">1.2.2 内存间交互操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-对于-volatile-型变量的特殊规则"><span class="toc-number">5.</span> <span class="toc-text">1.2.3 对于 volatile 型变量的特殊规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-原子性-可见性与有序性"><span class="toc-number">6.</span> <span class="toc-text">1.2.4 原子性,可见性与有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原子性"><span class="toc-number">6.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可见性"><span class="toc-number">6.2.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有序性"><span class="toc-number">6.3.</span> <span class="toc-text">有序性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-先行发生原则"><span class="toc-number">7.</span> <span class="toc-text">1.2.4 先行发生原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Java-与线程"><span class="toc-number">8.</span> <span class="toc-text">1.3 Java 与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-线程的实现"><span class="toc-number">8.1.</span> <span class="toc-text">1.3.1 线程的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-线程的实现"><span class="toc-number">8.2.</span> <span class="toc-text">Java 线程的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-Java-线程调度"><span class="toc-number">9.</span> <span class="toc-text">1.3.2 Java 线程调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-状态转换"><span class="toc-number">10.</span> <span class="toc-text">1.3.3 状态转换</span></a></li></ol></div></div><div class="post-content"><p>本篇文章,首先了解虚拟机Java 内存模型的结构及操作,然后讲解原子性,可见性,有序性在 Java 内存模型中的体现,最后介绍先行发生原则的规则和使用.<br>在多数情况下让计算机同时去做几件事情,不仅是因为计算机的运算能力强大,还有一个重要的原因是计算机的运算速度与它的存储和通信子系统速度的差距太大,大量的时间都花费在磁盘 I/O, 网络通信或者数据库访问上.<br><a id="more"></a></p>
<h3 id="1-1-硬件的效率与一致性"><a href="#1-1-硬件的效率与一致性" class="headerlink" title="1.1 硬件的效率与一致性"></a>1.1 硬件的效率与一致性</h3><p>计算机的存储设备与处理器运算速度有很大的差距,所以加入了一层高效缓存来作为内存与处理器之间的缓冲:将运算需要的数据复制到缓冲区中,让运算快读进行,当计算完毕之后再将结果从缓冲区同步到内存.但这样做也引入一个新的问题,缓存一致性.</p>
<h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><p>在多处理系统中,每个处理器都有各自的高效缓存,而它们共享同一内存,当涉及到同一块主内存区域时,将可能导致缓存数据不一致.为了解决一致性的问题,需要各个处理器访问缓存时都遵循一些协议.在读写时根据协议来操作.Java 虚拟机有自己的内存模型,内存模型可以理解为在特定的操作协议下,对特定的内存或高速缓存进行读写访问的抽象过程.</p>
<p>为了使处理器内部单元充分利用,处理器对输入代码进行乱序执行优化,在计算之后将乱序执行的结果重组.保证结果一致.但不保证各个语句计算的先后顺序与输入代码一致.</p>
<h3 id="1-2-Java-内存模型"><a href="#1-2-Java-内存模型" class="headerlink" title="1.2 Java 内存模型"></a>1.2 Java 内存模型</h3><p>Java 虚拟机试图定义一种 Java 内存模型来屏蔽各种硬件和操作系统的内存访问差异,实现在各个平台内存访问的一致性.</p>
<h3 id="1-2-1-主内存与工作内存"><a href="#1-2-1-主内存与工作内存" class="headerlink" title="1.2.1 主内存与工作内存"></a>1.2.1 主内存与工作内存</h3><p>Java 内存模型主要目标是定义程序中各个变量的访问规则,即虚拟机中从内存中存储和取出变量的底层细节.此处的变量与 Java 编程中的变量有所区别,包括实例字段,静态字段和构成数组对象的元素,但不包括局部变量与方法参数,因为后者是线程私有的,不会被分享.自然就不会存在竞争问题.</p>
<p>Java 内存模型规定所有的变量都存储在主内存中.每条线程还有自己的工作内存,工作内存中保存被该线程使用变量的主内存副本拷贝.线程中所有操作必须在工作内存进行,不能直接读写主内存中的变量,不同线程不能直接访问其它工作内存的变量,线程间的传递需要通过主内存完成.</p>
<h3 id="1-2-2-内存间交互操作"><a href="#1-2-2-内存间交互操作" class="headerlink" title="1.2.2 内存间交互操作"></a>1.2.2 内存间交互操作</h3><ul>
<li>lock(锁定):作用于主内存变量,将一个变量标识为一条线程独占的状态</li>
<li>unlock(解锁):作用于主内存变量,将处于锁定状态的变量释放出来,释放的变量才可以被其它线程锁定.</li>
<li>read(读取):用作于主内存变量,将一个变量的值从主内存传输到线程的工作内存,以便随后的 load 动作使用</li>
<li>load(载入):用作与工作内存的变量,把 read 操作从主内存中得到的变量值放入工作内存的变量副本中.</li>
<li>use(使用):作用于工作内存的变量,把工作内存中一个变量的值传递给执行引擎.当虚拟机的字节码指令使用到变量的值时将会执行这个操作.</li>
<li>assign(赋值):用作与工作内存的变量,将一个从执行引擎接收到的值赋值给工作内存的变量,当虚拟机的字节码执行遇到一个给变量赋值时执行这个操作.</li>
<li>sore(存储):作用于工作内存变量,将工作内存一个变量值传宋到主内存中,以便随后的 write 操作的使用.</li>
<li>write(写入):用作与主内存的变量,将 store 操作从工作内存中得到的值放入主内存的变量中.</li>
</ul>
<p>如果要把一个变量从主内存复制到工作内存,就要顺序的执行 read和load 操作.如果要把变量从工作内存同步回主内存,就要顺序执行 store 和 write 操作.</p>
<h3 id="1-2-3-对于-volatile-型变量的特殊规则"><a href="#1-2-3-对于-volatile-型变量的特殊规则" class="headerlink" title="1.2.3 对于 volatile 型变量的特殊规则"></a>1.2.3 对于 volatile 型变量的特殊规则</h3><p>关键字 volatile 是 java 虚拟机提供的最轻量级的同步机制,但它并不容易完全被正确,完成地理解.</p>
<p>当一个变量定义为 volatile 之后,将具备两种特性,第一是保证变量对所有线程的可见性,当一个线程修改了这个变量的值,其他线程可以立即得到新值.第二是禁止指令重排序优化,普通的变量仅仅保证方法的执行过程中所有依赖赋值结果的地方都能获取到正确结果,而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致.</p>
<h3 id="1-2-4-原子性-可见性与有序性"><a href="#1-2-4-原子性-可见性与有序性" class="headerlink" title="1.2.4 原子性,可见性与有序性"></a>1.2.4 原子性,可见性与有序性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>基本数据类型的访问读写是具备原子性的,如果应该场景需要一个更大范围的原子性操作,在 Java 中就是使用 synchronized同步代码块操作也具备原子性.</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性指当一个线程修改了共享变量的值,其他线程能够立即得知这个修改.</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>Java 内存模型中程序天然有序性可以总结为:在本线程内观察,所有操作都是有序的.如果在一个线程观察另一个线程,所有操作都是无序的.</p>
<h3 id="1-2-4-先行发生原则"><a href="#1-2-4-先行发生原则" class="headerlink" title="1.2.4 先行发生原则"></a>1.2.4 先行发生原则</h3><p>先行发生是Java 内存模型中定义的两项操作之间的偏序关系,如果说操作 A 先发生于操作 B ,也就是发生操作B 之前,操作 A 产生的影响能被操作 B 观察到,”影响”包括修改了内存中共享变量的值,发送了消息,调用方法等.</p>
<h3 id="1-3-Java-与线程"><a href="#1-3-Java-与线程" class="headerlink" title="1.3 Java 与线程"></a>1.3 Java 与线程</h3><h4 id="1-3-1-线程的实现"><a href="#1-3-1-线程的实现" class="headerlink" title="1.3.1 线程的实现"></a>1.3.1 线程的实现</h4><p>线程是比进程更轻量级的调度单位,线程可以把一个进程的资源分配和执行调度分开,各个线程既可以共享进程资源,又可以独立调度.</p>
<p>实现线程主要有3种方式</p>
<ol>
<li>使用内核线程实现</li>
</ol>
<p>内核线程是直接由操作系统内核支持的线程,这种线程由内核来完成线程切换,内核通过操纵调度器对线程进行调度,并负责将线程的任务映射到各个处理器上.</p>
<p>但是它有局限性,首先由于是基于内核线程实现,所以各种线程操作都需要进行线程调用.而系统调用的代价相对较高,需要在用户态和内核态中来回切换.其次每个轻量级进程都需要一个内核线程支持,因此轻量级进程要消耗一定内核资源,因此一个系统支持轻量级进程的数量是有限的.</p>
<ol start="2">
<li>使用用户线程实现</li>
</ol>
<p>广义上讲,一个线程只要不是内核线程就可以认为是用户线程</p>
<p>狭义上的用户线程指完全建立在用户空间的线程库上.系统内核不会感知线程存在,用户线程的操作完全在用户态中完成,不需要内核的帮助.</p>
<p>使用用户线程的优势在于不需要系统内核支援,劣势也在于没有系统内核支援所有操作都需要用户进程自己处理.Java,Ruby 等语言曾经使用过用户进程,最终又都放弃.</p>
<ol start="3">
<li>使用用户线程加轻量级进程混合实现</li>
</ol>
<p>在这种混合实现下,即存在用户线程,也存在轻量级进程.用户线程还是完全建立在用户空间中,而操作系统提供的轻量级进程则作为用户线程与讷河线程之间的桥梁,这样可以使用内核提供的线程调度功能以及处理器映射.</p>
<h4 id="Java-线程的实现"><a href="#Java-线程的实现" class="headerlink" title="Java 线程的实现"></a>Java 线程的实现</h4><p>在 JDK1.2中线程模型替换为基于操作系统原生线程模型来实现.因此操作系统支持怎样的线程模型,很大程度上决定了 Java 虚拟机的线程是怎样映射的.</p>
<h3 id="1-3-2-Java-线程调度"><a href="#1-3-2-Java-线程调度" class="headerlink" title="1.3.2 Java 线程调度"></a>1.3.2 Java 线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程,主要调度方式有两种:协同式线程调度和抢占式线程调度.</p>
<p>协同式多线程系统,线程的执行时间是由线程本身来控制.当线程工作执行完毕之后,要主动通知系统切换到另一个线程上.缺点是线程时间不可控制,容易造成程序阻塞.</p>
<p>抢占式调度多线程系统,每个线程由系统来分配执行时间,线程的切换不由线程本身来决定,Java 使用抢占式调度.</p>
<h3 id="1-3-3-状态转换"><a href="#1-3-3-状态转换" class="headerlink" title="1.3.3 状态转换"></a>1.3.3 状态转换</h3><p>Java 语言定义了5种线程状态,在一个线程点,一个线程只能有且只有一种状态</p>
<ul>
<li>新建,运行,等待, 阻塞, 结束</li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://caimuhao.com/2017/02/06/Efficient-Concurrent/" data-id="cjjrzv99u0002622ql0gkddja" class="article-share-link">Aktie</a><div class="tags"><a href="/tags/Android/">Android</a></div><div class="post-nav"><a href="/2017/02/07/Thread-Safety-Lock-Optimize/" class="pre">高效并发二 线程安全与锁优化</a><a href="/2017/01/07/Jack-And-Jill/" class="next">Jack和Jill 你应该在你下个安卓app中应用吗？</a></div><div id="uyan_frame"><script src="http://v2.uyan.cc/code/uyan.js?uid='2128928'"></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://caimuhao.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/19/myNewTestBlog/">myNewTestBlog</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/14/How-Kotlin-implements-extension-function/">Kotlin 扩展函数实现原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/09/Learn-Kotlin-While-Developing-An-Android-App-Part9/">Kotlin — Part 9:单元测试与 Kotlin(Mockito,RxJava)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/08/Learn-Kotlin-While-Developing-An-Android-App-Part8/">Kotlin — Part 8:方向改变(序列化&数据类)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/07/Learn-Kotlin-While-Developing-An-Android-App-Part7/">Kotlin — Part 7:无限滑动:高阶函数&Lambdas</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/07/Learn-Kotlin-While-Developing-An-Android-App-Part6/">Kotlin — Part 6:API-Retrofit&Kotlin</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/Learn-Kotlin-While-Developing-An-Android-App-Part5/">Kotlin — Part 5:Kotlin,RxJava&RxAndroid</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/05/Learn-Kotlin-While-Developing-An-Android-App-Part4/">Kotlin — Part 4:RecyclerView— Kotlin 委托适配器&数据类</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/04/Learn-Kotlin-While-Developing-An-Android-App-Part3/">Kotlin — Part 3:扩展函数、Android 扩展、委托属性</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/03/Learn-Kotlin-While-Developing-An-Android-App-Part2/">Kotlin — Part 2:语法,空安全,静态类型</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://caimuhao.com" title="muhao的程序世界" target="_blank">muhao的程序世界</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">技术边界.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-96217954-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fe6b71e8cdb10443de01da9a977207e9";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>