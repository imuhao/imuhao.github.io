<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Kotlin — Part 4:RecyclerView— Kotlin 委托适配器&amp;数据类 | 技术边界</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在这第四个部分,我们将介绍的 Kotlin 主题:  初始化函数 对象表达式 单个表达式 数据类 分类 List &amp;amp; Lambdas(介绍)">
<meta name="keywords" content="Kotlin">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin — Part 4:RecyclerView— Kotlin 委托适配器&amp;数据类">
<meta property="og:url" content="http://caimuhao.com/2017/11/05/Learn-Kotlin-While-Developing-An-Android-App-Part4/index.html">
<meta property="og:site_name" content="技术边界">
<meta property="og:description" content="在这第四个部分,我们将介绍的 Kotlin 主题:  初始化函数 对象表达式 单个表达式 数据类 分类 List &amp;amp; Lambdas(介绍)">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006DXQWggy1fl797ewc8nj30pr0hj7dk.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/006DXQWggy1fl83anynvbj309n01r0st.jpg">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tNc79gy1fl84yoysauj30kg11wn2f.jpg">
<meta property="og:updated_time" content="2017-11-10T01:16:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kotlin — Part 4:RecyclerView— Kotlin 委托适配器&amp;数据类">
<meta name="twitter:description" content="在这第四个部分,我们将介绍的 Kotlin 主题:  初始化函数 对象表达式 单个表达式 数据类 分类 List &amp;amp; Lambdas(介绍)">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/006DXQWggy1fl797ewc8nj30pr0hj7dk.jpg">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/scrollUp/image.css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div class="logo">
        <img src="/logo.png" alt="Profile Picture">
      </div>
      <div id="title">技术边界</div>
      
       <ul class="my-socials">
  
 
</ul>
    </div>
  </div>
  <div id="header-inner" class="">
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <!--
        
          
            <a class="main-nav-link" href="/">首页</a>
          
            <a class="main-nav-link" href="/archives">归档</a>
          
            <a class="main-nav-link" href="/about">关于</a>
          
        
      -->
    </nav>
    <nav id="title-nav" style="display:none">
      <a href="/">技术边界</a>
      <img src="/logo.png" alt="Smile">
      <!--
      <span id="title-nav-socials">
        
       
     </span>
      -->
    </nav>
    <nav id="sub-nav">
      
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
        <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
        <input type="submit" value="" class="search-form-submit">
        <input name=tn type=hidden value="bds">
        <input name=cl type=hidden value="3">
        <input name=ct type=hidden value="2097152">
        <input type="hidden" name="si" value="caimuhao.com">
      </form>
    </div>
  </div>
  <div class="site-nav" style="display: none;">
    <ul>
      
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
      
    </ul>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Learn-Kotlin-While-Developing-An-Android-App-Part4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/05/Learn-Kotlin-While-Developing-An-Android-App-Part4/" class="article-date">
  <time datetime="2017-11-05T09:48:00.000Z" itemprop="datePublished">2017-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Kotlin — Part 4:RecyclerView— Kotlin 委托适配器&amp;数据类
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
           
            <div id="toc" class="toc">
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建-NewsAdapter"><span class="toc-text">创建 NewsAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ViewType"><span class="toc-text">ViewType</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#让我们添加Loading视图到我们的-RecyclerView"><span class="toc-text">让我们添加Loading视图到我们的 RecyclerView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Loading-委托适配器实现"><span class="toc-text">Loading 委托适配器实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用委托适配器绑定-ViewType-类型"><span class="toc-text">用委托适配器绑定 ViewType 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Init-构造器"><span class="toc-text">Init 构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加载-ViewType-类型"><span class="toc-text">加载 ViewType 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象表达式"><span class="toc-text">对象表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单个表达式"><span class="toc-text">单个表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Commit"><span class="toc-text">Commit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新闻-Item-与数据类"><span class="toc-text">新闻 Item 与数据类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Commit-创建数据类"><span class="toc-text">Commit:创建数据类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建-NewsDelegateAdapter"><span class="toc-text">创建 NewsDelegateAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Picasso-扩展函数"><span class="toc-text">Picasso 扩展函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间扩展函数"><span class="toc-text">时间扩展函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NewsView-Android-扩展"><span class="toc-text">NewsView Android 扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更新-NewsAdapter-查看新闻"><span class="toc-text">更新 NewsAdapter 查看新闻</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Range"><span class="toc-text">Range</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mutableListOf"><span class="toc-text">mutableListOf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lists-函数-amp-Lambdas"><span class="toc-text">Lists 函数 &amp; Lambdas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Filter"><span class="toc-text">Filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambdas"><span class="toc-text">Lambdas</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结论"><span class="toc-text">结论</span></a></li></ol>
</div>

         
        <p>在这第四个部分,我们将介绍的 Kotlin 主题:</p>
<ul>
<li>初始化函数</li>
<li>对象表达式</li>
<li>单个表达式</li>
<li>数据类</li>
<li>分类</li>
<li>List &amp; Lambdas(介绍)</li>
</ul>
<a id="more"></a>
<p><strong>全部章节:</strong></p>
<blockquote>
<p><a href="http://caimuhao.com/2017/11/02/Learn-Kotlin-While-Developing-An-Android-App-Introduction/">Kotlin — Part 0:关于这个系列</a><br><a href="http://caimuhao.com/2017/11/03/Learn-Kotlin-While-Developing-An-Android-App-Part1/">Kotlin — Part 1:配置 Android Studio</a><br><a href="http://caimuhao.com/2017/11/03/Learn-Kotlin-While-Developing-An-Android-App-Part2/">Kotlin — Part 2:语法,空安全,静态类型</a><br><a href="http://caimuhao.com/2017/11/04/Learn-Kotlin-While-Developing-An-Android-App-Part3/">Kotlin — Part 3:扩展函数、Android 扩展、委托属性</a><br><a href="http://caimuhao.com/2017/11/05/Learn-Kotlin-While-Developing-An-Android-App-Part4/">Kotlin — Part 4:RecyclerView— Kotlin 适配器委托&amp;数据类</a><br><a href="http://caimuhao.com/2017/11/06/Learn-Kotlin-While-Developing-An-Android-App-Part5/">Kotlin — Part 5:Kotlin,RxJava&amp;RxAndroid</a><br><a href="- [Kotlin — Part 6:API-Retrofit&amp;Kotlin](http://caimuhao.com/2017/11/07/Learn-Kotlin-While-Developing-An-Android-App-Part6/">Kotlin — Part 6:API-Retrofit&amp;Kotlin</a>)<br><a href="http://caimuhao.com/2017/11/07/Learn-Kotlin-While-Developing-An-Android-App-Part7/">Kotlin — Part 7:无限滑动:高阶函数&amp; Lambdas</a><br><a href="http://caimuhao.com/2017/11/08/Learn-Kotlin-While-Developing-An-Android-App-Part8/">Kotlin — Part 8:方向改变(序列化&amp;数据类)</a><br><a href="http://caimuhao.com/2017/11/09/Learn-Kotlin-While-Developing-An-Android-App-Part9/">Kotlin — Part 9:单元测试与 Kotlin(Mockito,RxJava)</a></p>
</blockquote>
<p>Github 仓库:<a href="https://github.com/imuhao/KedditBySteps" target="_blank" rel="noopener">https://github.com/imuhao/KedditBySteps</a></p>
<h3 id="创建-NewsAdapter"><a href="#创建-NewsAdapter" class="headerlink" title="创建 NewsAdapter"></a>创建 NewsAdapter</h3><p>我们将为 RecyclerView创建一个新的适配器,在这种情况下我们将使用一个模式叫做” Delegate Adapter”,它是我看的<a href="http://hannesdorfmann.com/android/adapter-delegates" target="_blank" rel="noopener">这篇文章</a>受的启发.</p>
<p>我们的 Adapter 将是一个委托列表适配器,它负责知道 RecyclerView 如何加载和返回一个指定的 View.一般的做法是接受一个 ViewType 列表,然后委托适配器根据 ViewType 加载和填充视图到 item 中.我们将通过参数将 item 传递给委托适配器,所以 item 可以根据指定的是数据到这个 View.</p>
<p>背后的思想是匹配委托适配器可以匹配指定的 item, 像下面的图片:</p>
<p><img src="http://ww1.sinaimg.cn/large/006DXQWggy1fl797ewc8nj30pr0hj7dk.jpg" alt=""><br>感谢 ViewType ,我们的委托适配器知道需要为这个 item 创建那个 View.在这种情况下我们将会有一个列表的 items ,在列表的底部将添加一个加载的 item 来显示正在加载更多的状态.所以我们需要两个委托适配器,一个是新闻,另一个是加载状态.</p>
<p>这个方法给予你许多的灵活性来添加新类型的 View 到你的 RecyclerView. 只需要添加一个新的委托适配器来对应一个新类型的 ViewType.例如, 我们可以为促销活动添加一个新的 ViewType,对应的委托适配器加载一个促销活动视图.</p>
<h4 id="ViewType"><a href="#ViewType" class="headerlink" title="ViewType"></a>ViewType</h4><p>是一个用来显示 RecyclerView 上 item 的接口.每一个 item 必须实现这个接口,所以我们可以得到每一个 item 的 ViewType.然后根据这个类型搜索对性的委托适配器.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface ViewType &#123;</span><br><span class="line">    fun getViewType(): Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的 Adapter 将有一个集合存储 ViewType 集合.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private var items: ArrayList&lt;ViewType&gt;</span><br></pre></td></tr></table></figure>
<p>在这里我们来存储新闻和加载的 item. 我们新模型将继承 ViewType. 我们将为加载 item 创建一个新的本地 item.</p>
<h4 id="让我们添加Loading视图到我们的-RecyclerView"><a href="#让我们添加Loading视图到我们的-RecyclerView" class="headerlink" title="让我们添加Loading视图到我们的 RecyclerView"></a>让我们添加Loading视图到我们的 RecyclerView</h4><p>我们需要做3件事:</p>
<ul>
<li><strong>这个 ViewType 的类型:</strong>这是一个 integer 类型的 id, 来匹配我们的 ViewType 与委托适配器.</li>
<li><strong>这个 ViewType 的 Item:</strong>这是一个实现 ViewType接口 的对象,返回它的 ViewType 类型.这将允许我们插入这个 item 到我们的 items 集合,告诉适配器如何渲染这个 View.</li>
<li><strong>加载中的委托适配器:</strong>将负责加载我们的视图,返回给我们的 NewsAdapter.</li>
</ul>
<h4 id="Loading-委托适配器实现"><a href="#Loading-委托适配器实现" class="headerlink" title="Loading 委托适配器实现"></a>Loading 委托适配器实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface ViewTypeDelegateAdapter &#123;</span><br><span class="line"></span><br><span class="line">    fun onCreateViewHolder(parent: ViewGroup): RecyclerView.ViewHolder</span><br><span class="line"></span><br><span class="line">    fun onBindViewHolder(holder: RecyclerView.ViewHolder, item: ViewType)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class LoadingDelegateAdapter : ViewTypeDelegateAdapter &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreateViewHolder(parent: ViewGroup): RecyclerView.ViewHolder = TurnsViewHolder(parent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, item: ViewType) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class TurnsViewHolder(parent: ViewGroup) : RecyclerView.ViewHolder(parent.inflate(R.layout.news_item_loading)) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以看到我们通过实现” ViewTypeDelegateAdapter”接口,创建了我们自己的委托适配器.这个接口允许我们有一个通用的列表委托适配器,调用这个方法将不需要 NewsAdapter 知道委托适配器具体的实现.一个方法来创建 ViewHolder 另一个绑定数据.</p>
<h4 id="用委托适配器绑定-ViewType-类型"><a href="#用委托适配器绑定-ViewType-类型" class="headerlink" title="用委托适配器绑定 ViewType 类型"></a>用委托适配器绑定 ViewType 类型</h4><p>我们将为 ViewType 与委托适配器绑定一个映射.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private var delegateAdapters = SparseArrayCompat&lt;ViewTypeDelegateAdapter&gt;()</span><br><span class="line">   init &#123;</span><br><span class="line">       delegateAdapters.put(AdapterConstants.LOADING, LoadingDelegateAdapter())</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Init-构造器"><a href="#Init-构造器" class="headerlink" title="Init 构造器"></a>Init 构造器</h4><p>init 是Kotlin 中的一个保留字,它代表一个类的构造函数.在这里我们初始化 map ,添加每一个 ViewType 类型和相应的委托适配器.在这种情况下:</p>
<p>AdapterConstants.LOADING &gt; LoadingDelegateAdapter()</p>
<blockquote>
<p>在 Kotlin 中创建一个对象不需要使用 new 关键字</p>
</blockquote>
<h4 id="加载-ViewType-类型"><a href="#加载-ViewType-类型" class="headerlink" title="加载 ViewType 类型"></a>加载 ViewType 类型</h4><p>让我们来创建Loading Item, 我们将插入到 items 集合中,这个 item 将根据位置加载视图.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private val loadingItem = object : ViewType &#123;</span><br><span class="line">       override fun getViewType(): Int = AdapterConstants.LOADING</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>将这个 item 添加到items 集合中的第一个位置来渲染它.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init &#123;</span><br><span class="line">       delegateAdapters.put(...)</span><br><span class="line">       items = ArrayList()</span><br><span class="line">       items.add(loadingItem)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h4><p>在 Kotlin 中有一个叫”Object expressions”的东西,它类似 Java 中的匿名内部类,允许你显示地创建一个新的子类,在这种情况下我们没有创建一个新类文件来创建了一个加载 item.这个语法是非常直观的,你可以看到我们从 ViewType接口派生了一个类并且实现了需要的方法.</p>
<h4 id="单个表达式"><a href="#单个表达式" class="headerlink" title="单个表达式"></a>单个表达式</h4><p>这个 getViewType() 函数在内部只有一个表达式.在 Kotlin 中我们可以利用 Kotlin 的优势,来转换这个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override fun getViewType() : Int &#123;</span><br><span class="line">    return AdapterConstants.LOADING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转变为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override fun getViewType() = AdapterConstants.LOADING</span><br></pre></td></tr></table></figure>
<p>它像我们将 AdapterConstants.LOADING 分配给一个函数.这是一个短的方法做相同实现,更加简洁.你也不需要指定返回类型,它可以从上下文中推断出来.所以它现在看起来这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private val loadingItem = object : ViewType &#123;</span><br><span class="line">        override fun getViewType() = AdapterConstants.LOADING</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h4><p>所有的代码可以在这里查看:</p>
<p><a href="https://github.com/imuhao/KedditBySteps/commit/74e770e2bd18340e23d42520bdf23fb03b98d05b" target="_blank" rel="noopener">https://github.com/imuhao/KedditBySteps/commit/74e770e2bd18340e23d42520bdf23fb03b98d05b</a></p>
<h3 id="新闻-Item-与数据类"><a href="#新闻-Item-与数据类" class="headerlink" title="新闻 Item 与数据类"></a>新闻 Item 与数据类</h3><p>在创建我们的新闻委托适配器之前,配置 NewsAdapter 来接受新闻集合,我们需要 UI 对象代表每一个新闻.在 Java 中正常情况下需要这样一个类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class RedditNewsItem &#123;</span><br><span class="line"></span><br><span class="line">    private String author;</span><br><span class="line">    private String title;</span><br><span class="line"></span><br><span class="line">    public MyNews(String author, String title) &#123;</span><br><span class="line">        this.author = author;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAuthor() &#123;</span><br><span class="line">        return author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthor(String author) &#123;</span><br><span class="line">        this.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTitle() &#123;</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitle(String title) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin 再一次为我们带来帮助的是一个叫做” data class”的数据类型,它带来的许多的方便,下面是这个相同的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class RedditNewsItem(var author: String, var title: String) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用者简单的一行就完成了之前 Java 代码相同的功能,它意味着 author 和 title 有自己的 getter 和 setter 方法,它有一个构造器需要两个参数,这是非常惊人的!但是等等!使用这个数据类你会有更多的好处:</p>
<ul>
<li><strong>equals/hashCode</strong>方法</li>
<li><strong>toString()</strong>包含所有的参数</li>
<li><strong>copy()</strong>方法简单的复制这个对象</li>
<li>还有其它有用的方法在这我们没有说,你可以在<a href="https://kotlinlang.org/docs/reference/data-classes.html" target="_blank" rel="noopener">这个页面</a>查看更多</li>
</ul>
<h4 id="Commit-创建数据类"><a href="#Commit-创建数据类" class="headerlink" title="Commit:创建数据类"></a>Commit:创建数据类</h4><p><a href="https://github.com/imuhao/KedditBySteps/commit/8367173a606e325bf8366a59041ae8e76f958765" target="_blank" rel="noopener">https://github.com/imuhao/KedditBySteps/commit/8367173a606e325bf8366a59041ae8e76f958765</a></p>
<p>另外我们需要我们的类继承 <strong>ViewType</strong>,这样它就可以包含在 NewsAdapter 的 items 中作为一个 item.在这种情况下作为一个新的 Item:</p>
<p><a href="https://github.com/imuhao/KedditBySteps/commit/cc01da4eebb3a7820bfcb921cc96c91b06603365" target="_blank" rel="noopener">https://github.com/imuhao/KedditBySteps/commit/cc01da4eebb3a7820bfcb921cc96c91b06603365</a></p>
<h3 id="创建-NewsDelegateAdapter"><a href="#创建-NewsDelegateAdapter" class="headerlink" title="创建 NewsDelegateAdapter"></a>创建 NewsDelegateAdapter</h3><p>现在我们已经创建了新闻 Bean 对象,我们需要委托适配器负责创建 View.这有一个我们需要做的预览图:</p>
<p><img src="http://ww1.sinaimg.cn/large/006DXQWggy1fl83anynvbj309n01r0st.jpg" alt=""><br>所以我们需要:</p>
<ul>
<li>显示一些文本像 title, 头像,评论</li>
<li>一个图片,我们将使用 Picasso</li>
<li>一个显示时间的扩展方法</li>
</ul>
<p>这里有所有我们创建 NewsDelegateAdapter 的方法.我们将不再说明每一个细节:</p>
<p>让我们重新查看一些 Kotlin 的东西</p>
<h4 id="Picasso-扩展函数"><a href="#Picasso-扩展函数" class="headerlink" title="Picasso 扩展函数"></a>Picasso 扩展函数</h4><p>运行我们使用 ImageView 加载一个网络图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun ImageView.loadImg(imageUrl: String) &#123;</span><br><span class="line">    if (TextUtils.isEmpty(imageUrl)) &#123;</span><br><span class="line">        Picasso.with(context).load(R.mipmap.ic_launcher).into(this)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Picasso.with(context).load(imageUrl).into(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时间扩展函数"><a href="#时间扩展函数" class="headerlink" title="时间扩展函数"></a>时间扩展函数</h4><p>我们将从 Reddit 接受一个时间,这个时间是一个 long 格式,我们将转换 Long 类型到一个字符串类型,像”3 day and 1 minute age”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun Long.getFriendlyTime(): String &#123;</span><br><span class="line">    // logic here...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开文件” TimeExt.kt”来查看代码,</p>
<h4 id="NewsView-Android-扩展"><a href="#NewsView-Android-扩展" class="headerlink" title="NewsView Android 扩展"></a>NewsView Android 扩展</h4><p>打开文件” NewsDelelgateAdapter.kt”,你将查看我们也使用了 Android Extension, 但是在这种情况下我们添加了 synthetic 包,在结尾添加了一个”view”额外值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import kotlinx.android.synthetic.main.news_item.view.*</span><br></pre></td></tr></table></figure>
<p>这是一个在没有 Activity 或Fragment 上下文时绑定 View 的一个办法.</p>
<h4 id="更新-NewsAdapter-查看新闻"><a href="#更新-NewsAdapter-查看新闻" class="headerlink" title="更新 NewsAdapter 查看新闻"></a>更新 NewsAdapter 查看新闻</h4><p>让我们修改 NewsAdapter 接受一个新闻集合,来显示我们的新闻列表和正在加载状态.</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fl84yoysauj30kg11wn2f.jpg" alt=""></p>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>Kotlin 允许你通过”1..10”这种表达式简单的创建一个范围的数字(Int,Long 和Char),IntRange 继承 IntProgression实现了 Iterable 接口.感谢这个特征我们可以迭代一个范围的数字,下面是从1到10的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(i in 1..10)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以控制它间隔的步数,或使他递减像从10到1.更多关于这个你可以在<a href="https://kotlinlang.org/docs/reference/ranges.html" target="_blank" rel="noopener">这里找到</a></p>
<h4 id="mutableListOf"><a href="#mutableListOf" class="headerlink" title="mutableListOf"></a>mutableListOf</h4><p>这是一个 Kotlin 函数,返回一个 MutableList, 一个可以被修改的集合,在这种情况下我们用来存储适配器中的 news 集合.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val news = mutableListOf&lt;RedditNewsItem&gt;()</span><br></pre></td></tr></table></figure>
<h4 id="Lists-函数-amp-Lambdas"><a href="#Lists-函数-amp-Lambdas" class="headerlink" title="Lists 函数 &amp; Lambdas"></a>Lists 函数 &amp; Lambdas</h4><p>我们将创建一个方法,在晚些时候使用,我们使用 filter 和 map 事件将集合中的 item 转换到另一种类型.</p>
<p>在我们的代码中有一个” getNews”方法,返回一个 RedditNewsItems 集合.为了 过滤和转换我们的列表,我们需要这样做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun getNews(): List&lt;RedditNewsItem&gt; &#123;</span><br><span class="line">       return items.filter &#123;</span><br><span class="line">           it.getViewType() == AdapterConstants.NEWS</span><br><span class="line">       &#125;.map &#123;</span><br><span class="line">           it as RedditNewsItem</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>每一个 list 都有一些有用的函数 像” filter”,允许我们使用一些条件过滤集合中的数据.在我们的 items 集合中保存的 ViewType 类型,里面的类型有 News item 或Loading item, 使用 filter 函数,我们确保只返回 news item .</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>另一个伟大的函数式” map”,他对集合中的每一项进行转换,在这种情况下我们将 ViewType 类型转换成一个 RedditnNewsItem. 另外,我们也返回一个新创建的对象.</p>
<h4 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.map&#123;it as RedditNewsItem&#125;</span><br></pre></td></tr></table></figure>
<p>Map 不是一个新的事物,但是 Kotlin 使它更伟大,因为它允许你在函数名后定义代码块,省略了括号.这个代码块就是 Lambda 表达式,一个不需要定义的函数.</p>
<p>在这里我们没有花更多的时间讲解关于 List 和 Lambdas,但是我想这是一个好的起点来了解如何使用这个伟大的特性,在之后的章节我们将花费更多的时间来谈论关于这个.</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我知道我花费了更多的时间来解释委托适配器模式,我考虑到这个模式是一个很优秀的模式,我希望通过这个代码你学习到了 Kotlin 新的特征.</p>
<p>GitHub 仓库地址:<a href="https://github.com/imuhao/KedditBySteps" target="_blank" rel="noopener">https://github.com/imuhao/KedditBySteps</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://caimuhao.com/2017/11/05/Learn-Kotlin-While-Developing-An-Android-App-Part4/" data-id="cjkf90u5v000tmr2qknzixkr9" class="article-share-link">Share</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin/">Kotlin</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/06/Learn-Kotlin-While-Developing-An-Android-App-Part5/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Kotlin — Part 5:Kotlin,RxJava&amp;RxAndroid
        
      </div>
    </a>
  
  
    <a href="/2017/11/04/Learn-Kotlin-While-Developing-An-Android-App-Part3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Kotlin — Part 3:扩展函数、Android 扩展、委托属性</div>
    </a>
  
</nav>

  
</article>


</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      Software Engineer. Blogging about tech and life.<br>
      <!-- Theme <a href="https://github.com/henryhuang/oishi" target="_blank">Oishi</a>, Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> -->
      &copy; 2018 muhao
      
      <div style="display:none"><script src="https://s95.cnzz.com/z_stat.php?id=1260308592&web_id=1260308592" language="JavaScript"></script></div>
    </div>
  </div>
</footer>

    </div>
    <!--
      <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    -->
    

<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>



<script src="/js/jquery.scrollUp.min.js"></script>
<script src="/js/jquery.transform.js"></script>
<script src="/js/menu.js"></script>

<script src="/js/script.js"></script>
<script src="/js/scrollUp.js"></script>

  </div>
</body>
</html>